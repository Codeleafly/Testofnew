<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System with MediaPipe Hand Control</title>
    
    <!-- Three.js for 3D Rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Updated Minimal UI at Bottom Center */
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .status-text { font-size: 0.9rem; font-weight: 500; }
        .highlight { color: #00f260; font-weight: bold; }
        
        /* Video Container with Landmarks Canvas */
        #video-wrapper {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #4facfe;
            z-index: 10;
            background: #222;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        #input_video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }
        
        #output_canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror the drawing too */
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            text-align: center;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 20;
        }
        
        button {
            background: linear-gradient(to right, #4facfe 0%, #00f260 100%);
            border: none;
            padding: 8px 16px;
            color: white;
            font-weight: bold;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #00f260;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px auto;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .instructions { font-size: 0.75rem; color: #aaa; margin-left: 10px; border-left: 1px solid #444; padding-left: 10px; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div class="status-text" id="status-msg">MediaPipe Solar System</div>
        <div class="instructions">
            <span>üñê Move to Rotate</span> | 
            <span>üëå Pinch to Zoom</span>
        </div>
        <button id="start-btn" onclick="startCamera()">Start Camera</button>
    </div>

    <div id="loading" style="display: none;">
        <div class="spinner"></div>
        <div>Loading AI Model...</div>
    </div>

    <!-- Video & Canvas Wrapper -->
    <div id="video-wrapper">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        // --- 1. Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
        const sunLight = new THREE.PointLight(0xffffff, 2, 800);
        scene.add(sunLight);

        // Planets Data
        const planets = [];
        const planetData = [
            { name: "Mercury", size: 1.2, color: 0xA5A5A5, distance: 20, speed: 0.04 },
            { name: "Venus", size: 2.5, color: 0xE1C699, distance: 30, speed: 0.015 },
            { name: "Earth", size: 2.6, color: 0x2233FF, distance: 45, speed: 0.01 },
            { name: "Mars", size: 1.8, color: 0xFF4500, distance: 60, speed: 0.008 },
            { name: "Jupiter", size: 8, color: 0xC88B3A, distance: 90, speed: 0.004 },
            { name: "Saturn", size: 7, color: 0xE4D0A4, distance: 130, speed: 0.002, hasRings: true },
            { name: "Uranus", size: 4, color: 0x4FD0E7, distance: 170, speed: 0.001 },
            { name: "Neptune", size: 3.8, color: 0x4B70DD, distance: 200, speed: 0.0008 }
        ];

        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for(let i=0; i<8000; i++) {
            starVertices.push((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({color: 0xffffff, size: 1.5}));
        scene.add(stars);

        // Sun
        const sun = new THREE.Mesh(
            new THREE.SphereGeometry(10, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xFFCC00 })
        );
        scene.add(sun);

        // Create Planets
        planetData.forEach(data => {
            const orbitGroup = new THREE.Group();
            
            const path = new THREE.Mesh(
                new THREE.RingGeometry(data.distance - 0.2, data.distance + 0.2, 64),
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, opacity: 0.05, transparent: true })
            );
            path.rotation.x = Math.PI / 2;
            scene.add(path);

            const planet = new THREE.Mesh(
                new THREE.SphereGeometry(data.size, 32, 32),
                new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.7 })
            );
            planet.position.x = data.distance;
            
            if(data.hasRings) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(data.size + 4, 1.5, 2, 64),
                    new THREE.MeshStandardMaterial({ color: 0xA09070, opacity: 0.8, transparent: true })
                );
                ring.rotation.x = Math.PI / 2.2;
                planet.add(ring);
            }

            orbitGroup.add(planet);
            scene.add(orbitGroup);
            planets.push({ mesh: orbitGroup, speed: data.speed, planetMesh: planet });
        });

        // --- Camera & Interaction State ---
        let targetRotationX = 0;
        let targetRotationY = 0;
        let currentRotationX = 0;
        let currentRotationY = 0;
        
        let targetZoom = 250;
        let currentZoom = 250;
        const minZoom = 50;  // Closest
        const maxZoom = 400; // Farthest

        // Initial Pos
        camera.position.set(0, 50, 250);
        camera.lookAt(0, 0, 0);

        // --- 2. MediaPipe Integration ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const statusMsg = document.getElementById('status-msg');
        const loadingDiv = document.getElementById('loading');
        let cameraUtils;

        function onResults(results) {
            loadingDiv.style.display = 'none';

            // Draw Landmarks on Canvas
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw skeleton
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00f260', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#4facfe', lineWidth: 1, radius: 3});

                // --- Control Logic ---
                
                // 1. Rotation (Index Tip Position)
                const x = landmarks[8].x; 
                const y = landmarks[8].y;
                // Invert X for mirror feel, Scale up for sensitivity
                targetRotationY = (x - 0.5) * 5; 
                targetRotationX = (y - 0.5) * 3;

                // 2. Zoom (Pinch Distance: Thumb Tip 4 & Index Tip 8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                // Euclidean distance
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // Map distance (approx 0.02 to 0.3) to Zoom (400 to 50)
                // Wide Pinch (0.2) -> Zoom In (Small Radius)
                // Closed Pinch (0.02) -> Zoom Out (Large Radius)
                // Let's create a smooth mapping
                
                const pinchFactor = Math.max(0, Math.min(1, (distance - 0.02) * 4)); 
                // pinchFactor 0 = closed, 1 = wide open
                
                // Invert mapping: Wide (1) -> Close Zoom (minZoom)
                const desiredZoom = maxZoom - (pinchFactor * (maxZoom - minZoom));
                targetZoom = desiredZoom;

                // UI Update
                startBtn.textContent = "Active";
                startBtn.style.background = "transparent";
                startBtn.style.border = "1px solid #00f260";
                startBtn.style.color = "#00f260";
                statusMsg.innerHTML = "Tracking: <span class='highlight'>ON</span>";

            } else {
                statusMsg.innerHTML = "Tracking: <span style='color:orange'>Waiting...</span>";
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        async function startCamera() {
            startBtn.style.display = 'none';
            loadingDiv.style.display = 'block';
            
            // Fix canvas size to match video aspect
            canvasElement.width = 320;
            canvasElement.height = 240;

            try {
                cameraUtils = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 320,
                    height: 240
                });
                await cameraUtils.start();
            } catch (error) {
                console.error("Camera error:", error);
                loadingDiv.innerHTML = "Error accessing camera.";
                alert("Camera access is required.");
            }
        }

        // --- 3. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Orbit Planets
            planets.forEach(p => {
                p.mesh.rotation.y += p.speed;
                p.planetMesh.rotation.y += 0.01;
            });

            // Smooth Camera Movement
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;
            currentZoom += (targetZoom - currentZoom) * 0.05;

            // Update Camera Position (Spherical Coordinates)
            // Y rotation controls Azimuth (Left/Right)
            // X rotation controls Elevation (Up/Down)
            
            const radius = currentZoom;
            const theta = currentRotationY + Math.PI / 2; 
            const phi = Math.max(0.1, Math.min(Math.PI - 0.1, currentRotationX + Math.PI / 2)); // Offset to center vertically

            camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
            camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
            camera.position.y = radius * Math.cos(phi);
            
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
